name: Self-hosted Runner Workflow

on:
  workflow_dispatch: {}
  push:
    branches:
      - master
  pull_request:
    types:
      - opened
      - synchronize
      - closed

jobs:
  setup:
    runs-on: self-hosted
    env:
      DOTCOVER_VERSION: 2023.2.2
    steps:
      - name: Check dotCover Windows
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $exePath = "..\dotCover\dotCover.exe"
  
          if (Test-Path -Path $exePath -PathType Leaf) {
            Write-Host "dotCover.exe exists at the specified location."
          } else {
            Write-Host "dotCover.exe does not exist at the specified location, downloading it."
            $url = "https://download.jetbrains.com/resharper/dotUltimate.$env:DOTCOVER_VERSION/JetBrains.dotCover.CommandLineTools.windows-x64.$env:DOTCOVER_VERSION.zip"
            echo "Downloading dotCover from $url"
            $outputPath = "..\dotCover.zip"
            $extractPath = "..\dotCover"
            
            Invoke-WebRequest -Uri $url -OutFile $outputPath -Verbose
            Expand-Archive -Path $outputPath -DestinationPath $extractPath -Force -Verbose
            Remove-Item -Path $outputPath -Force -Verbose
          }
      - name: Check dotCover Linux and macOS
        if: runner.os != 'Windows'
        run: |
          if [ ! -e "../dotCover/dotCover.sh" ]; then
            echo "dotCover.sh does not exist at the specified location, downloading it."
          else
            echo "dotCover.sh exists at the specified location."
            exit 0
          fi
          
          if [[ $(uname -m) != "x86_64" ]]; then
            if [[ $RUNNER_OS == "Linux" ]]; then
              download_url="https://download.jetbrains.com/resharper/dotUltimate.$DOTCOVER_VERSION/JetBrains.dotCover.CommandLineTools.linux-arm64.$DOTCOVER_VERSION.tar.gz"
            else
              download_url="https://download.jetbrains.com/resharper/dotUltimate.$DOTCOVER_VERSION/JetBrains.dotCover.CommandLineTools.macos-arm64.$DOTCOVER_VERSION.tar.gz"
            fi
          else
            if [[ $RUNNER_OS == "Linux" ]]; then
              download_url="https://download.jetbrains.com/resharper/dotUltimate.$DOTCOVER_VERSION/JetBrains.dotCover.CommandLineTools.linux-x64.$DOTCOVER_VERSION.tar.gz"
            else
              download_url="https://download.jetbrains.com/resharper/dotUltimate.$DOTCOVER_VERSION/JetBrains.dotCover.CommandLineTools.macos-x64.$DOTCOVER_VERSION.tar.gz"
            fi
          fi
          echo "Downloading dotCover from $download_url"
          # Define the download and output paths
          output_path="../dotCover.tar.gz"
          extract_path="../dotCover"
          wget -O "$output_path" "$download_url"
          mkdir -p "$extract_path"
          tar -xzvf "$output_path" -C "$extract_path"
          rm "$output_path"

      - name: Check out code
        uses: actions/checkout@v2
      - name: Check if Unity is in PATH Linux
        if: runner.os != 'Windows'
        run: |
          UNITY_PATH=$(which unity)
  
          if [ -n "$UNITY_PATH" ]; then
            echo "Unity is installed and is located at: $UNITY_PATH"
          
            # Extract the Unity version from the executable path
            UNITY_VERSION=$(echo "$UNITY_PATH" | grep -oP '(\d{4}\.\d+\.\d+[a-z]+\d+)')
            
            # Read the Unity version from ProjectVersion.txt
            PROJECT_VERSION_FILE="./ProjectSettings/ProjectVersion.txt"
            PROJECT_VERSION=$(grep -oP 'm_EditorVersion: \K(\d{4}\.\d+\.\d+[a-z]+\d+)' "$PROJECT_VERSION_FILE")
            
            if [ "$PROJECT_VERSION" = "$UNITY_VERSION" ]; then
              echo "Unity versions match: ProjectVersion.txt version is $PROJECT_VERSION and Unity path version is $UNITY_VERSION."
            else
              echo "Unity versions do not match: ProjectVersion.txt version is $PROJECT_VERSION, but Unity path version is $UNITY_VERSION."
              exit 1
            fi
          else
            echo "Unity is not installed or not in the PATH."
            exit 1  # This line will stop the script with a failure status.
          fi
      - name: Check if Unity is in PATH Windows
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          $UNITY_PATH = Get-Command -ErrorAction SilentlyContinue -Name 'unity.exe' | Select-Object -ExpandProperty Source
          if ($UNITY_PATH) {
            Write-Host "Unity is installed and is located at: $UNITY_PATH"
            # Compare the two versions
            $projectVersionFile = ".\ProjectSettings\ProjectVersion.txt"
            $projectVersion = Get-Content $projectVersionFile | Where-Object { $_ -match "m_EditorVersion:" } | ForEach-Object { $_ -replace "m_EditorVersion: ", "" }
            $pattern = "(\d{4}\.\d+\.\d+[a-z]+\d+)"
            $unityVersion = [regex]::Match($UNITY_PATH, $pattern).Groups[1].Value
            if ($projectVersion -eq $unityVersion) {
              Write-Host "Unity versions match: ProjectVersion.txt version is $projectVersion and Unity path version is $unityVersion."
            } else {
              Write-Host "Unity versions do not match: ProjectVersion.txt version is $projectVersion, but Unity path version is $unityVersion."
              exit 1
            }
          } else {
            Write-Host "Unity is not installed or not in the PATH."
            exit 1  # This line will stop the workflow with a failure status.
          }
      - name: Generate Project
        run: unity -batchmode -quit -projectPath . -logfile -
      - name: Create output directory 
        run: |
          $path = "../CiOutput/$(git branch --show-current)/$(git rev-parse HEAD)"

  tests:
    runs-on: self-hosted
    needs: setup
    steps:
      - name: list
        run: dir
        
  analyze:
    runs-on: self-hosted
    needs: setup
    steps:
      - name: check roslynator is installed Windows
        if: runner.os == 'Windows'
        run: |
          $ROSLYNATOR_PATH = Get-Command -ErrorAction SilentlyContinue -Name 'roslynator.exe' | Select-Object -ExpandProperty Source
          if($ROSLYNATOR_PATH) {
            Write-Host "Roslynator is installed and is located at: $ROSLYNATOR_PATH"
          }
          else{
            $url = "https://dot.net/v1/dotnet-install.ps1"
            $outputPath = "./dotnet-install.ps1"
            Invoke-WebRequest -Uri $url -OutFile $outputPath -Verbose
            ./dotnet-install.ps1 -Channel LTS -InstallDir $HOME/.dotnet
            ./dotnet-install.ps1 -Channel LTS -Runtime dotnet -InstallDir $HOME/.dotnet
            [System.Environment]::SetEnvironmentVariable("PATH", $Env:PATH + ";$HOME/.dotnet;$HOME/.dotnet/tools", [System.EnvironmentVariableTarget]::User)
            $env:PATH = [System.Environment]::GetEnvironmentVariable("PATH", [System.EnvironmentVariableTarget]::User)
            dotnet tool install -g roslynator.dotnet.cli
          }
      - name: check roslynator is installed Linux
        if: runner.os != 'Windows'
        run: |
          if ! command -v roslynator &> /dev/null
          then
            wget https://dot.net/v1/dotnet-install.sh -O dotnet-install.sh
            chmod +x dotnet-install.sh
            ./dotnet-install.sh --version latest
            ./dotnet-install.sh --version latest --runtime 'dotnet'
            echo "export DOTNET_ROOT=$HOME/.dotnet" >> ~/.bashrc
            echo "export PATH=$PATH:$DOTNET_ROOT:$DOTNET_ROOT/tools" >> ~/.bashrc
            source ~/.bashrc
            dotnet tool install -g roslynator.dotnet.cli
          fi
      - name: run roslynator analyze 
        run: roslynator analyze ./*.sln -o ../CiOutput/$(git branch --show-current)/$(git rev-parse HEAD)/analyze.xml

  commit:
    runs-on: self-hosted
    needs: [tests, analyze]
    steps:
      - name: commit
        run: |
          $commitMessage = "$(git branch --show-current)/$(git rev-parse HEAD)"
          # go on branch CI
          git checkout CI
          mv ../CiOutput/* ./CiOutput
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          git add ./CiOutput
          git commit -m "Update CI output from $commitMessage"
          git push

  cleanup:
    runs-on: self-hosted
    needs: [tests, analyze]
    steps:
      - name: cleanup Windows
        if: runner.os == 'Windows'
        shell: powershell
        run: Remove-Item * -Force -Recurse
      - name: cleanup Linux
        if: runner.os != 'Windows'
        run: rm -r -- !(.) .*
